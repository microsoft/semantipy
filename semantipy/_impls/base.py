from __future__ import annotations

from typing import Type, Callable, TypeVar

from semantipy.semantics import Semantics
from semantipy.ops.base import Dispatcher, SupportsSemanticFunction


_registered_backends: list[Type[BaseBackend]] = []


def list_backends():
    return _registered_backends.copy()


def register_backend(backend):
    _registered_backends.append(backend)
    return backend


def unregister_backend(backend):
    # Remove last occurrence of backend
    _registered_backends.reverse()
    _registered_backends.remove(backend)
    _registered_backends.reverse()
    return backend


class BaseBackend:
    """Backend namespace that implements the operations."""

    @classmethod
    def register(cls):
        return register_backend(cls)

    @classmethod
    def __semantic_dependencies__(cls) -> list[type[SupportsSemanticFunction]]:
        """Return a list of backends that this backend depends on."""
        return []

    @classmethod
    def __semantic_function__(
        cls,
        func: Callable,
        kwargs: dict,
        dispatcher: Dispatcher | None = None,
        plan: BaseExecutionPlan | None = None,
    ) -> BaseExecutionPlan:
        """Called when the backend is selected by the dispatcher.

        The method should return a new execution plan or the same plan if no changes are needed.
        dispatcher can be optional for debugging and testing purposes.

        Raise BackendNotImplemented if the backend does not implement the function.
        """
        raise NotImplementedError()


BackendType = TypeVar("BackendType", bound=BaseBackend)


def register(backend: Type[BackendType]) -> Type[BackendType]:
    return backend.register()


class ReflectionBackend(BaseBackend):
    """Base class for backends that use reflection to implement the operations."""

    @classmethod
    def __semantic_function__(
        cls,
        func: Callable,
        kwargs: dict,
        dispatcher: Dispatcher | None = None,
        plan: BaseExecutionPlan | None = None,
    ) -> BaseExecutionPlan:
        func_name = func.__name__
        if not hasattr(cls, func_name):
            raise BackendNotImplemented(f"Backend {cls.__name__} does not implement {func_name}")
        return LambdaExecutionPlan(lambda: getattr(cls, func_name)(**kwargs))


@register
class TypedBackend(BaseBackend):
    """Backend that redirects the request to the definition of types."""

    @classmethod
    def __semantic_function__(
        cls,
        func: Callable,
        kwargs: dict,
        dispatcher: Dispatcher | None = None,
        plan: BaseExecutionPlan | None = None,
    ) -> BaseExecutionPlan:
        if dispatcher is not None:
            prepended_handlers = []
            for value in kwargs.values():
                if isinstance(value, Semantics) and type(value) not in prepended_handlers:
                    prepended_handlers.append(type(value))
            for i, handler in enumerate(prepended_handlers):
                dispatcher.handlers.insert(i, handler)

        if plan is not None:
            return plan
        return DummyPlan(signer=cls.__name__)


@register
class RendererBackend(BaseBackend):
    """Backend that uses a renderer to implement the operations."""

    @classmethod
    def __semantic_function__(
        cls,
        func: Callable,
        kwargs: dict,
        dispatcher: Dispatcher | None = None,
        plan: BaseExecutionPlan | None = None,
    ) -> BaseExecutionPlan:
        from semantipy.ops import cast

        if func != cast:
            return NotImplemented
        
        if plan is not None:
            # Never modify the existing plan
            return plan

        args = (kwargs["s"],)
        if "target_type" in kwargs:
            args += (kwargs["target_type"],)

        if kwargs.get("renderer") is not None:
            renderers = [kwargs["renderer"]]
        else:
            if kwargs["target_type"] is None:
                raise ValueError("target_type is required for rendering when renderer is not specified")

            # unify this queue with the global queue
            from semantipy.renderer import list_renderers
            renderers = list_renderers(type(kwargs["s"]), kwargs["target_type"])

        for renderer in renderers:
            plan = renderer().render_plan(*args)
            plan.sign(cls.__name__, f"rendered by {renderer.__name__}")
            if plan is not NotImplemented:
                return plan

        return NotImplemented


class BaseExecutionPlan:
    """Execution plan generated by backends.

    When backends are invoked, they do not execute the operation directly. Instead, they return an execution plan.
    The execution plan is then returned to and executed by the dispatcher.

    The design is for several purposes:

    1. Multiple backends can co-edit one execution plan before it is executed.
       For example, contextual backends can add examples to the prompt.
    2. The execution plan can be cached as one kind of "compiled" program.
    """

    _signs: list[str]
    _final: bool = False

    @property
    def final(self):
        """Indicating the plan is the final plan and should be no more modified."""
        return self._final

    def set_final(self):
        self._final = True

    def sign(self, who: str, msg: str):
        """For a backend to sign a plan, indicating the changes it made."""
        if not hasattr(self, "_signs"):
            self._signs = []
        self._signs.append(f"[{who}] {msg}")

    def list_signs(self):
        if not hasattr(self, "_signs"):
            return []
        return self._signs

    def execute(self):
        raise NotImplementedError()


class LambdaExecutionPlan(BaseExecutionPlan):

    def __init__(self, lambda_func: Callable):
        self.lambda_func = lambda_func

    def execute(self):
        return self.lambda_func()


class DummyPlan(BaseExecutionPlan):
    """A plan that does nothing."""

    def __init__(self, final: bool = False, signer: str | None = None):
        super().__init__()
        if signer is not None:
            self.sign(signer, "created")
        if final:
            self.set_final()

    def execute(self):
        return None


class BackendNotImplemented(Exception):
    pass
