from __future__ import annotations

from typing import Type, Callable, TypeVar

from semantipy.semantics import Semantics
from semantipy.ops.base import Dispatcher, SupportsSemanticFunction, SemanticOperationRequest


_registered_backends: list[Type[BaseBackend]] = []


def list_backends():
    return _registered_backends.copy()


def register_backend(backend):
    _registered_backends.append(backend)
    return backend


def unregister_backend(backend):
    # Remove last occurrence of backend
    _registered_backends.reverse()
    _registered_backends.remove(backend)
    _registered_backends.reverse()
    return backend


class BaseBackend:
    """Backend namespace that implements the operations."""

    @classmethod
    def register(cls):
        return register_backend(cls)

    @classmethod
    def __semantic_dependencies__(cls) -> list[type[SupportsSemanticFunction]]:
        """Return a list of backends that this backend depends on."""
        return []

    @classmethod
    def __semantic_function__(
        cls,
        request: SemanticOperationRequest,
        dispatcher: Dispatcher | None = None,
        plan: BaseExecutionPlan | None = None,
    ) -> BaseExecutionPlan:
        """Called when the backend is selected by the dispatcher.

        The method should return a new execution plan or the same plan if no changes are needed.
        dispatcher can be optional for debugging and testing purposes.

        Raise BackendNotImplemented if the backend does not implement the function.
        """
        raise NotImplementedError()


BackendType = TypeVar("BackendType", bound=BaseBackend)


def register(backend: Type[BackendType]) -> Type[BackendType]:
    return backend.register()


class BaseExecutionPlan:
    """Execution plan generated by backends.

    When backends are invoked, they do not execute the operation directly. Instead, they return an execution plan.
    The execution plan is then returned to and executed by the dispatcher.

    The design is for several purposes:

    1. Multiple backends can co-edit one execution plan before it is executed.
       For example, contextual backends can add examples to the prompt.
    2. The execution plan can be cached as one kind of "compiled" program.
    """

    _signs: list[str]
    _final: bool = False

    @property
    def final(self):
        """Indicating the plan is the final plan and should be no more modified."""
        return self._final

    def set_final(self):
        self._final = True

    def sign(self, who: str, msg: str):
        """For a backend to sign a plan, indicating the changes it made."""
        if not hasattr(self, "_signs"):
            self._signs = []
        self._signs.append(f"[{who}] {msg}")

    def list_signs(self):
        if not hasattr(self, "_signs"):
            return []
        return self._signs

    def execute(self):
        raise NotImplementedError()


class LambdaExecutionPlan(BaseExecutionPlan):
    """A plan that executes an arbitrary function."""

    def __init__(self, lambda_func: Callable):
        self.lambda_func = lambda_func

    def execute(self):
        return self.lambda_func()


class DummyPlan(BaseExecutionPlan):
    """A plan that does nothing."""

    def __init__(self, final: bool = False, signer: str | None = None):
        super().__init__()
        if signer is not None:
            self.sign(signer, "created")
        if final:
            self.set_final()

    def execute(self):
        return None


class BackendNotImplemented(Exception):
    pass
